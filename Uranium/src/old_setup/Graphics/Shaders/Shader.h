#pragma once

#include <string>

#include "ShaderTypes.h"

namespace Uranium::Graphics::Shaders {

	/*
	* Shader class implementation
	*/
	class Shader {
	public:
		/*
		* Constructs shader object as one of these four:
		*  ~ VERTEX_SHADER
		*  ~ FRAGMENT_SHADER
		*  ~ GEOMETRY_SHADER
		*  ~ COMPUTE_SHADER
		* 
		* filePath - determines the path of where in the shader file is located
		* 
		* shaderType - determines the type of shader that 'this' is going to construct
		* 
		*/
		Shader(const std::string& filePath, unsigned int shaderType);

		/*
		* Copy & move constructor
		*/
		Shader(const Shader&);
		Shader(Shader&&) noexcept;

		virtual ~Shader();
		
	public:
		/*
		* getters and setters
		*/
		
		/*
		* Returns the shader Id generated by constructor
		*/
		operator const ShaderId() const;

		/*
		* Returns the shader type:
		*  ~ VERTEX_SHADER
		*  ~ FRAGMENT_SHADER
		*  ~ GEOMETRY_SHADER
		*  ~ COMPUTE_SHADER
		*/
		inline unsigned int shaderType() const;

		/*
		* Returns the pointer to where 'this'
		* instance is currently been saved in memory
		*/
		std::shared_ptr<Shader> heapReference() const;

	private:
		/*
		* private methods
		*/

		/*
		* Extracts source code from file given
		* a file path. It then returns a string containing
		* the source code of the shader as a pointer
		*/
		void toSourceCode(const std::string& filePath, std::string* sourceCode);
		
		/*
		* Compiles the given source code as parameter
		* to machine code so OpenGl can understand it
		* and run the shader in Graphics card
		* 
		* Returns the generated shader Id after compiling successfully
		* 
		* Returns ShaderId == 0 (default shader) as error
		*/
		ShaderId compile(const std::string& sourceCode);

	private:
		/*
		* private members
		*/
		ShaderId shaderId;
		unsigned int sType;
		std::string filePath;
		std::string shaderSource;
	};
}